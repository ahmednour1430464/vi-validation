<?php

declare(strict_types=1);

namespace Vi\Validation\Compilation;

use Vi\Validation\Execution\CompiledField;
use Vi\Validation\Execution\CompiledSchema;
use Vi\Validation\Rules\RuleInterface;
use ReflectionClass;
use RuntimeException;

/**
 * NativeCompiler generates highly optimized PHP code for validation schemas.
 * It inlines common rules to minimize method calls and object allocations.
 */
final class NativeCompiler
{
    public const COMPILER_VERSION = '1.0.0';

    /**
     * Compile a schema into optimized PHP code.
     */
    public function compile(CompiledSchema $schema): string
    {
        $code = "<?php\n\n";
        $code .= "declare(strict_types=1);\n\n";
        $code .= "/**\n";
        $code .= " * Optimized validation function generated by NativeCompiler.\n";
        $code .= " * Compiler Version: " . self::COMPILER_VERSION . "\n";
        $code .= " * PHP Version: " . PHP_VERSION . " (" . PHP_VERSION_ID . ")\n";
        $code .= " * Generated at: " . date('Y-m-d H:i:s') . "\n";
        $code .= " */\n";
        $code .= "return function(array \$data) {\n";
        $code .= "    \$errors = [];\n";
        $code .= "    \$hasErrors = false;\n";
        $code .= "    \$excludedFields = [];\n\n";

        foreach ($schema->getFields() as $field) {
            $code .= $this->compileField($field);
        }

        $code .= "    return [\n";
        $code .= "        'valid' => !\$hasErrors,\n";
        $code .= "        'errors' => \$errors,\n";
        $code .= "        'excluded_fields' => \$excludedFields,\n";
        $code .= "    ];\n";
        $code .= "};\n";

        return $code;
    }

    /**
     * Generate a unique key for the rules that includes PHP version and compiler version.
     */
    /**
     * @param array<string, mixed> $rules
     */
    public static function generateKey(array $rules): string
    {
        return sha1(serialize($rules) . PHP_VERSION_ID . self::COMPILER_VERSION);
    }

    private function compileField(CompiledField $field): string
    {
        $name = $field->getName();
        // Create a safe label for goto
        $safeName = preg_replace('/[^a-zA-Z0-9_]/', '_', $name);
        $varName = '$val_' . $safeName;
        
        $rules = $field->getRules();
        $rulesNames = array_map(function($r) {
            return (new ReflectionClass($r))->getShortName();
        }, $rules);
        $rulesStr = implode('|', $rulesNames);

        $code = "    // --- field: {$name} | rules: {$rulesStr} ---\n";
        $code .= "    {$varName} = " . $this->generateGetValueCode($field) . ";\n";

        $indent = "    ";
        $suffix = "";

        // Handle sometimes: skip if key doesn't exist
        if ($field->isSometimes()) {
            $code .= "{$indent}if (array_key_exists('" . addslashes($name) . "', \$data)) {\n";
            $indent .= "    ";
            $suffix = substr($indent, 0, -4) . "}\n" . $suffix;
        }

        // Handle nullable: skip rules if value is null
        if ($field->isNullable()) {
            $code .= "{$indent}if ({$varName} !== null) {\n";
            $indent .= "    ";
            $suffix = substr($indent, 0, -4) . "}\n" . $suffix;
        }

        foreach ($rules as $rule) {
            $inlined = $this->inlineRule($rule, $name, $varName, $indent);
            if ($inlined) {
                $code .= $inlined;
            } else {
                $code .= "{$indent}// Warning: Rule " . get_class($rule) . " not inlined. Skipping.\n";
            }
            
            if ($field->isBail()) {
                $code .= "{$indent}if (isset(\$errors['" . addslashes($name) . "'])) { goto bail_{$safeName}; }\n";
            }
        }

        if ($field->isBail()) {
            $code .= "    bail_{$safeName}:\n";
        }

        $code .= "{$suffix}\n";

        return $code;
    }

    private function generateGetValueCode(CompiledField $field): string
    {
        $name = $field->getName();
        if (strpos($name, '.') === false) {
            return "\$data['" . addslashes($name) . "'] ?? null";
        }

        $parts = explode('.', $name);
        if (count($parts) === 2) {
             return "(isset(\$data['" . addslashes($parts[0]) . "']) && is_array(\$data['" . addslashes($parts[0]) . "'])) ? (\$data['" . addslashes($parts[0]) . "']['" . addslashes($parts[1]) . "'] ?? null) : null";
        }
        
        return "\\Vi\\Validation\\Execution\\DataHelper::get(\$data, '" . addslashes($name) . "')";
    }

    private function inlineRule(RuleInterface $rule, string $fieldName, string $valName, string $indent): ?string
    {
        $class = get_class($rule);
        
        // Non-implicit rules should skip if the value is "empty"
        // Implicit rules (Required, Accepted, etc.) handle empty values themselves.
        $isImplicit = $this->isImplicitRule($class);
        $prefix = "";
        $suffix = "";
        
        if (!$isImplicit) {
            $prefix = "{$indent}if (!(\$val === null || (is_string(\$val) && \$val === '') || (is_array(\$val) && \$val === []))) {\n";
            $prefix = str_replace("\$val", $valName, $prefix);
            $indent .= "    ";
            $suffix = substr($indent, 0, -4) . "}\n";
        }

        $code = match($class) {
            \Vi\Validation\Rules\RequiredRule::class => $this->inlineRequired($fieldName, $valName, $indent),
            \Vi\Validation\Rules\StringTypeRule::class => $this->inlineType($fieldName, $valName, 'string', 'is_string', $indent),
            \Vi\Validation\Rules\IntegerTypeRule::class => $this->inlineInteger($fieldName, $valName, $indent),
            \Vi\Validation\Rules\NumericRule::class => $this->inlineType($fieldName, $valName, 'numeric', 'is_numeric', $indent),
            \Vi\Validation\Rules\BooleanRule::class => $this->inlineBoolean($fieldName, $valName, $indent),
            \Vi\Validation\Rules\ArrayRule::class => $this->inlineType($fieldName, $valName, 'array', 'is_array', $indent),
            \Vi\Validation\Rules\EmailRule::class => $this->inlineEmail($fieldName, $valName, $indent),
            \Vi\Validation\Rules\UrlRule::class => $this->inlineFilter($fieldName, $valName, 'url', FILTER_VALIDATE_URL, $indent),
            \Vi\Validation\Rules\IpRule::class => $this->inlineFilter($fieldName, $valName, 'ip', FILTER_VALIDATE_IP, $indent),
            \Vi\Validation\Rules\JsonRule::class => $this->inlineJson($fieldName, $valName, $indent),
            \Vi\Validation\Rules\MinRule::class => $this->inlineMinMax($rule, $fieldName, $valName, 'min', '<', $indent),
            \Vi\Validation\Rules\MaxRule::class => $this->inlineMinMax($rule, $fieldName, $valName, 'max', '>', $indent),
            \Vi\Validation\Rules\AlphaRule::class => $this->inlineRegex($fieldName, $valName, 'alpha', '/^\pL+$/u', $indent),
            \Vi\Validation\Rules\AlphanumericRule::class => $this->inlineRegex($fieldName, $valName, 'alpha_num', '/^[\pL\pN]+$/u', $indent),
            \Vi\Validation\Rules\AlphaDashRule::class => $this->inlineRegex($fieldName, $valName, 'alpha_dash', '/^[\pL\pM\pN_-]+$/u', $indent),
            default => null,
        };

        if ($code === null) {
            return null;
        }

        return $prefix . $code . $suffix;
    }

    private function isImplicitRule(string $class): bool
    {
        return in_array($class, [
            \Vi\Validation\Rules\RequiredRule::class,
            \Vi\Validation\Rules\RequiredIfRule::class,
            \Vi\Validation\Rules\RequiredUnlessRule::class,
            \Vi\Validation\Rules\RequiredWithRule::class,
            \Vi\Validation\Rules\RequiredWithAllRule::class,
            \Vi\Validation\Rules\RequiredWithoutRule::class,
            \Vi\Validation\Rules\RequiredWithoutAllRule::class,
            \Vi\Validation\Rules\AcceptedRule::class,
            \Vi\Validation\Rules\AcceptedIfRule::class,
            \Vi\Validation\Rules\FilledRule::class,
            \Vi\Validation\Rules\PresentRule::class,
            \Vi\Validation\Rules\ProhibitedRule::class,
            \Vi\Validation\Rules\ProhibitedIfRule::class,
            \Vi\Validation\Rules\ProhibitedUnlessRule::class,
        ], true);
    }

    private function inlineInteger(string $fieldName, string $valName, string $indent): string
    {
        return "{$indent}if (!is_int({$valName}) && !(is_string({$valName}) && preg_match('/^-?\d+$/', {$valName}))) {\n" .
               "{$indent}    \$errors['" . addslashes($fieldName) . "'][] = ['rule' => 'integer', 'message' => null];\n" .
               "{$indent}    \$hasErrors = true;\n" .
               "{$indent}}\n";
    }

    private function inlineRequired(string $fieldName, string $valName, string $indent): string
    {
        return "{$indent}if ({$valName} === null || (is_string({$valName}) && {$valName} === '') || (is_array({$valName}) && {$valName} === [])) {\n" .
               "{$indent}    \$errors['" . addslashes($fieldName) . "'][] = ['rule' => 'required', 'message' => null];\n" .
               "{$indent}    \$hasErrors = true;\n" .
               "{$indent}}\n";
    }

    private function inlineType(string $fieldName, string $valName, string $ruleName, string $func, string $indent): string
    {
        return "{$indent}if ({$valName} !== null && !{$func}({$valName})) {\n" .
               "{$indent}    \$errors['" . addslashes($fieldName) . "'][] = ['rule' => '{$ruleName}', 'message' => null];\n" .
               "{$indent}    \$hasErrors = true;\n" .
               "{$indent}}\n";
    }

    private function inlineBoolean(string $fieldName, string $valName, string $indent): string
    {
        return "{$indent}if ({$valName} !== null && !in_array({$valName}, [true, false, 0, 1, '0', '1'], true)) {\n" .
               "{$indent}    \$errors['" . addslashes($fieldName) . "'][] = ['rule' => 'boolean', 'message' => null];\n" .
               "{$indent}    \$hasErrors = true;\n" .
               "{$indent}}\n";
    }

    private function inlineEmail(string $fieldName, string $valName, string $indent): string
    {
        return "{$indent}if ({$valName} !== null && (!is_string({$valName}) || filter_var({$valName}, FILTER_VALIDATE_EMAIL) === false)) {\n" .
               "{$indent}    \$errors['" . addslashes($fieldName) . "'][] = ['rule' => 'email', 'message' => null];\n" .
               "{$indent}    \$hasErrors = true;\n" .
               "{$indent}}\n";
    }

    private function inlineFilter(string $fieldName, string $valName, string $ruleName, int $filter, string $indent): string
    {
         return "{$indent}if ({$valName} !== null && (!is_string({$valName}) || filter_var({$valName}, {$filter}) === false)) {\n" .
               "{$indent}    \$errors['" . addslashes($fieldName) . "'][] = ['rule' => '{$ruleName}', 'message' => null];\n" .
               "{$indent}    \$hasErrors = true;\n" .
               "{$indent}}\n";
    }

    private function inlineJson(string $fieldName, string $valName, string $indent): string
    {
        return "{$indent}if ({$valName} !== null) {\n" .
               "{$indent}    if (!is_string({$valName})) {\n" .
               "{$indent}        \$errors['" . addslashes($fieldName) . "'][] = ['rule' => 'json', 'message' => null];\n" .
               "{$indent}        \$hasErrors = true;\n" .
               "{$indent}    } else {\n" .
               "{$indent}        json_decode({$valName});\n" .
               "{$indent}        if (json_last_error() !== JSON_ERROR_NONE) {\n" .
               "{$indent}            \$errors['" . addslashes($fieldName) . "'][] = ['rule' => 'json', 'message' => null];\n" .
               "{$indent}            \$hasErrors = true;\n" .
               "{$indent}        }\n" .
               "{$indent}    }\n" .
               "{$indent}}\n";
    }

    private function inlineRegex(string $fieldName, string $valName, string $ruleName, string $pattern, string $indent): string
    {
        $patternExport = var_export($pattern, true);
        return "{$indent}if ({$valName} !== null && (!is_string({$valName}) || !preg_match({$patternExport}, (string){$valName}))) {\n" .
               "{$indent}    \$errors['" . addslashes($fieldName) . "'][] = ['rule' => '{$ruleName}', 'message' => null];\n" .
               "{$indent}    \$hasErrors = true;\n" .
               "{$indent}}\n";
    }

    private function inlineMinMax(RuleInterface $rule, string $fieldName, string $valName, string $ruleName, string $op, string $indent): string
    {
        $limit = $this->getProperty($rule, $ruleName);
        $limitExport = var_export($limit, true);

        $isNumeric = false;
        try {
            $isNumeric = $this->getProperty($rule, 'isNumeric');
        } catch (\Exception $e) {
            // Property might not exist or be accessible, default false
        }
        
        return "{$indent}if ({$valName} !== null) {\n" .
               "{$indent}    \$invalid = false;\n" .
               "{$indent}    if (" . ($isNumeric ? "is_numeric({$valName})" : "(is_int({$valName}) || is_float({$valName}))") . ") {\n" .
               "{$indent}        if ((float){$valName} {$op} {$limitExport}) \$invalid = true;\n" .
               "{$indent}        \$type_tag = 'numeric';\n" .
               "{$indent}    } elseif (is_string({$valName})) {\n" .
               "{$indent}        if (mb_strlen({$valName}) {$op} {$limitExport}) \$invalid = true;\n" .
               "{$indent}        \$type_tag = 'string';\n" .
               "{$indent}    } elseif (is_array({$valName})) {\n" .
               "{$indent}        if (count({$valName}) {$op} {$limitExport}) \$invalid = true;\n" .
               "{$indent}        \$type_tag = 'array';\n" .
               "{$indent}    } else {\n" .
               "{$indent}        \$type_tag = 'numeric';\n" .
               "{$indent}    }\n" .
               "{$indent}    if (\$invalid) {\n" .
               "{$indent}        \$errors['" . addslashes($fieldName) . "'][] = ['rule' => '{$ruleName}', 'params' => ['type' => \$type_tag, '{$ruleName}' => {$limitExport}], 'message' => null];\n" .
               "{$indent}        \$hasErrors = true;\n" .
               "{$indent}    }\n" .
               "{$indent}}\n";
    }

    private function getProperty(object $object, string $property): mixed
    {
        $reflection = new ReflectionClass($object);
        if (!$reflection->hasProperty($property)) {
             $parent = $reflection->getParentClass();
             if ($parent && $parent->hasProperty($property)) {
                 $prop = $parent->getProperty($property);
             } else {
                 throw new RuntimeException("Property {$property} not found in " . get_class($object));
             }
        } else {
            $prop = $reflection->getProperty($property);
        }
        $prop->setAccessible(true);
        return $prop->getValue($object);
    }
}
